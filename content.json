{"meta":{"title":"霍丙南的博客","subtitle":"","description":"说什么真理无限，进一步有一步的欢喜","author":"Huo Bingnan","url":"https://huobingnan.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-11-26T12:55:45.000Z","updated":"2020-11-26T12:56:02.305Z","comments":true,"path":"categories/index.html","permalink":"https://huobingnan.github.io/categories/index.html","excerpt":"","text":""},{"title":"schedule","date":"2020-11-26T12:57:28.000Z","updated":"2020-11-26T12:57:43.380Z","comments":true,"path":"schedule/index.html","permalink":"https://huobingnan.github.io/schedule/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-26T12:54:01.000Z","updated":"2020-11-26T12:54:58.397Z","comments":true,"path":"tags/index.html","permalink":"https://huobingnan.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-12-02T02:54:08.000Z","updated":"2020-12-02T02:54:08.104Z","comments":true,"path":"about/index.html","permalink":"https://huobingnan.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"自旋锁","slug":"自旋锁","date":"2020-12-01T13:17:28.000Z","updated":"2020-12-01T13:19:07.164Z","comments":true,"path":"2020/12/01/自旋锁/","link":"","permalink":"https://huobingnan.github.io/2020/12/01/%E8%87%AA%E6%97%8B%E9%94%81/","excerpt":"","text":"自旋锁我们通过上述C语言代码实现了一个简单的锁，其实这种锁还有一个名字——自旋锁。这种锁的实现简单，实现思路也非常的清晰明了，但是这个锁是一个表现良好的锁吗？ 在互斥性上，自旋锁能够做到良好的互斥性。但是从开销方面来看，这个锁并不是一个表现良好的锁。为什么这么说呢？因为自旋锁并没有真正的让其他线程去等待，用一个更为确切的词语说，自旋锁的策略是让其他线程阻塞。 事实上，上述临界区代码的执行过程中，没有获得锁的线程同样会获得操作系统分给它的CPU时间片。只不过它阻塞在lock的while循环上，这种操作有点浪费CPU的资源，因为它在这段时间内什么都没做，只是在不断的循环，直至把CPU时间片耗光，然后等待操作系统将CPU的使用权分配给其他线程，我们也称这种等待为有忙等待。 自旋锁的后话我们通过一个简单的数据结构+硬件原语的支持实现了一个简单的锁。这个锁具有良好的互斥性，但是我们诟病了这个锁的资源浪费。那么自旋真的就是不好的现象吗？事实上，自旋并非一种坏事，任何事物要评价它的好与坏，一定程度上也要看事物作用的环境。有些场景下，自旋的确是一个不错的选择，例如Linux系统中有一种叫做两阶段锁的自旋锁(two-phase-lock)，两阶段锁就意识到自旋可能很有用，尤其是在一些临界区代码很少，（如果临界区代码很少，一个线程一个CPU时间片内就能执行完代码，并且释放锁，那么在CPU时间片分给下一个线程时，下一个线程会立即进入临界区并执行，这样看来，自旋锁的效率会很高，也没有造成资源的浪费，或者在多核CPU的情况下，自旋锁在某些场景下也有不错的表现）线程很快会释放锁的场景。因此两阶段锁的第一阶段先会自旋一段时间，希望它能够获取到锁。 自旋锁的实现中，除了硬件原语test-and-set,还有一些其他的硬件原语也可以帮助自旋锁进行原子性的加锁操作。例如：compare-and-swap(CAS, 比较并交换),**LL/SC(链接加载和条件式存储指令)**。 除此之外，还有一种公平的自旋锁实现——ticket锁。ticket锁依赖于一个叫做**fetch-and-add(获取并增加)**的硬件原语去实现，如果有兴趣可以查阅相关资料了解ticket锁的实现。 非自旋锁的简单实现既然自旋锁的确有一些不可避免的开销，那么我们如何去实现一个“完美”的锁呢？既然没有获得锁之前，线程会一直自旋等待，那么有没有办法消除这种自旋等待呢？最简单的办法就是如果我不能获取到锁，我就跳出循环，这样不就不会自旋了吗？然而，我们跳出了循环，还必须要保障跳出循环之后不能进入临界区，这就有点棘手了。好在操作系统为我们提供了一个API——yield。 yield的这个API的历史很是久远，最初它的设计初衷是为了便于操作系统进行多任务的调度，所以期望程序员们在编程时可以在一些代码段中添加yield，一旦执行了yield函数，操作系统就会获得CPU的使用权，进而操作系统会暂时中止掉当前的进程，转而调度其他进程，这样可以时多个进程并发的执行，提高操作系统的交互性和进程响应时间。但是这种设计无疑是加重了程序员们的负担。所以这种方法最终没有应用于操作系统的任务调度器上。 尽管yield没有被用于任务调度器，但是对于当前我们面临的问题似乎是一个很好的方案，我们可以在获取不到锁的时候调用yieldAPI，进而转交控制权给操作系统，让操作系统继续调度其他线程，这样看来只需对代码进行少量修改，就能对原来的自旋锁进行一个不错的优化。 1234void lock(lock_t *mutex) &#123; while (test_and_set(&amp;mutex-&gt;flag, 1) == 1) yield();&#125; 然而事实上，这种实现也不是一个很好的方案，为什么这么说呢？尽管这样避免了无意义的循环操作，但是这会让操作系统陷入一种频繁切换线程上下文的操作，这种操作的开销也十分巨大。 假如我们当前有100个线程，只有一个线程获取到了锁，那么操作系统在最坏的情况下要进行99次的线程上下文切换操作才可以重新将CPU使用权交给当前拥有锁的线程。 这样的实现虽然避免了自旋，但又让线程进入了一种频繁的进入-跳出操作，又让操作系统执行了巨大的开销。 使用队列既然自旋和yield都不是一个很好的选择，那么我们可以选择使用队列的方式的进行。 1234567891011121314151617181920212223242526272829303132333435363738394041typedef struct lock_t &#123; int flag; int guard; queue_t *q;&#125; lock_t; /* 使用队列的锁 */void init(lock_t *mutex) &#123; mutex-&gt;flag = 0; mutex-&gt;guard = 0; init_queue(mutex-&gt;q);&#125;void lock(lock_t *mutex) &#123; /* 自旋锁 */ /* 锁的作用是保障只有一个线程完成队列的添加&amp;线程休眠工作和获得锁操作 */ while (test_and_set(&amp;mutex-&gt;guard, 1) == 1); if (mutex-&gt;flag == 0) &#123; /* 当前还有线程获得锁 */ mutex-&gt;flag = 1; mutex-&gt;guard = 0; &#125; else &#123; /* 已有线程获得锁，将此线程的ID号加入到等待队列中，并休眠 */ queue_add(mutex-&gt;q, gettid()); m-&gt;guard = 0; park(); /* 线程休眠 */ &#125; /* 从这里可以看出，自旋锁在针对比较小的临界区时，是很有效的 */&#125;void unlock(lock_t *mutex) &#123; /* 如果有线程正在尝试加锁，那么要阻塞 */ while (test_and_set(&amp;mutex-&gt;guard, 1) == 1); if (queue_empty(mutex-&gt;q)) mutex-&gt;flag = 0; /* 当前队列中没有线程想要获得锁，所以可以释放 */ else /* 当前队列中有线程想要获得锁，所以唤醒一个线程即可 */ /* 这里无需做锁的释放操作，原因是park()API的使用特性,下面会做详细讲解 */ unpark(queue_remove(mutex-&gt;q)); /* 唤醒一个线程 */ mutex-&gt;guard = 0;&#125; park和unpark同样是操作系统API，Solaris系统提供了这两个系统调用。这两个系统调用的作用： park，让线程睡眠。线程的状态将处于阻塞状态，一旦线程睡眠，他将不会获得操作系统调度，直到被唤醒。 同时当线程被唤醒时，被唤醒的线程会继续从park()函数所在位置开始执行。这也就是我们在上述代码中唤醒线程之后而不用释放锁的原因。 unpark，唤醒指定的睡眠的线程。 上述代码设计中其实有一个漏洞，那就是park操作不是原子的。也就是说，当一个线程被当前获得锁的线程唤醒时，他要从park函数开始执行，假如此时发生了中断，操作系统要切换线程，那么就会导致当前正在执行唤醒操作的线程永远的睡眠下去。但是我们也不能将park操作放入由mutex-guard确定的自旋锁中，这样会导致死锁问题。不过，Solaris操作系统意识到了这一点，它提供了一个新的setparkAPI帮助我们解决了这一原子性问题。 123456789101112void lock(lock_t *mutex) &#123; /* 尝试进入临界区 */ while (test_and_set(&amp;mutex-&gt;guard, 1) == 1); if (mutex-&gt;flag == 0) &#123; mutex-&gt;flag = 1; mutex-&gt;guard = 0; /* 退出临界区 */ &#125; else &#123; queue_add(mutex-&gt;q, gettid()); m-&gt;guard = 0; /* 退出临界区 */ setpark(); &#125;&#125;","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://huobingnan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://huobingnan.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"操作系统","slug":"操作系统","permalink":"https://huobingnan.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"临界区与锁","slug":"临界区与锁","date":"2020-12-01T12:59:56.000Z","updated":"2020-12-01T13:15:54.847Z","comments":true,"path":"2020/12/01/临界区与锁/","link":"","permalink":"https://huobingnan.github.io/2020/12/01/%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%B8%8E%E9%94%81/","excerpt":"","text":"临界区在多线程并发的环境下，多个线程在竞争着对同一资源对象进行操作，那么这两个线程将处于竞态条件(Race Condition)，竞态条件下执行的代码结果依赖于并发执行或者事件的顺序，这种结果往往具有不确定性和不可重现性。 临界区(Critical section) 是指进程中一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会执行的代码区域。简单说，临界区就是访问共享变量的代码段，这个代码段一定不能被多个线程同时执行。 临界区的特点 互斥性：同一时间，临界区最多只有一个线程进行访问。 Progress：如果一个线程想要进入临界区，那么它最终会成功。 有限等待：如果$线程_i$出入临界区入口，那么$线程_i$的请求被接受之前，其他线程进入临界区时间是有限制的。 无忙等待：如果一个线程在等待进入临界区，那么在此之前它可选择无忙等待。(Optional) 临界区是一种逻辑概念。那么针对于临界区的性质，有三种实现策略 基于硬件中断的实现。 基于软件 更深层次的抽象 基于中断的临界区实现在分时操作系统中，没有时钟中断，就没有上下文切换，就没有并发。操作系统的调度器的实现就是依赖于时钟中断。那么我们在实现临界区的时候，可以在一个线程进入临界区代码后主动禁用掉CPU对中断的响应，在线程离开临界区代码后，再开启CPU对中断的响应。这种实现可以实现良好的互斥性和其他临界区的特性。 但是这种实现并不是最好的实现，因为禁用CPU中断带来的开销非常大。一旦CPU中断响应被禁止，那么不仅仅是其他线程无法被调度，甚至一些基本的设备请求，网络请求等都会受到影响。而且一旦我们临界区代码的开销也同样巨大，那么这种实现的效果就会很差。换言之，这种实现的粒度太大了。 同时这种实现只能作用于单核CPU，对于多核CPU，就不能保障临界区的特性了。 基于软件的实现基于软件的实现，就是利用一下数据结构+算法，来实现临界区的功能。 例如Bakery算法： 12345678do&#123; flag[i] &#x3D; TRUE turn &#x3D; j while (flag[i] &amp;&amp; turn &#x3D;&#x3D; j); 进入临界区 flag[i] &#x3D; FALSE 离开临界区&#125;while(TRUE) 相对比基于中断的实现方式，基于软件的实现能够达到一种细粒度的控制。但是基于软件实现的方式会很复杂。 更深层次的抽象锁和信号量。它们是操作系统提供的更高级的编程抽象用来解决临界区问题。锁和信号量不仅能够解决共享数据问题，同时他也可以解决线程间同步的问题，同时可以将我们代码的稳定性提高，降低出现BUG的风险。这两个概念十分重要，它们是解决并发问题的关键，在下面的章节中会详细的介绍。 这种更高层次的抽象，并不是上述两种实现方法的Next Generation。而是借鉴了上述两种实现方式之后的一个更为通用和抽象的解决方案。 锁(Lock)之前章节我们讲过并发带来的一个基本问题——共享数据。出现这个问题的原因与指令执行的原子性有关(具体有关原子性的概念可以参照之前讲过的共享数据问题的哪一章节)。显然，单纯从指令的原子性上去避免共享数据问题有很大的难度，因为这个需要依赖于我们的硬件系统，需要硬件系统支持。 既然如此，那么应该选用哪种方法既不依赖于硬件，还可以让我们的代码原子性的去运行呢。我们可以从软件层面借助于一种数据结构去实现。这个数据结构便是锁。 锁是对于临界区的一种实现，锁本质上是一个数据结构。在编程中使用它，你可以像使用变量一样去使用。锁为程序员们提供了细粒度的并发控制。之前的章节我们讲过，线程是由程序员创建，由操作系统调度的。换言之，我们创建了线程之后交给了操作系统我们就丢失了对线程的控制权。锁这样的一个数据结构能够在线程调度方面帮助程序员们“曲线救国”。 如何去实现一个锁既然锁是对于临界区的一种实现，那么锁就应该具备临界区的基本要求。可以这么讲，任何锁都具备互斥性，这是临界区的基本要求。那么什么是互斥性？互斥性就是在涉及到对共享的变量进行操作的代码时，我们必须保证只有一个线程在操作，而且这个线程必须执行完毕临界区内的所有代码才可以让出临界区交给下一个线程处理。 锁的实现不仅仅只是软件层面的实现，当然仅靠软件(编写代码)去实现锁也可以，但是这样实现的锁不是一个最佳的锁。如果想要实现一个表现良好的锁一定程度上还需要依赖于硬件系统。所以，一个表现良好的锁是软硬结合去实现的。 如何去评价锁我们说到表现良好的锁，何为表现良好，怎么去评价。换言之，一个表现的锁体现在哪些方面上。 互斥性：最基本的条件，一个锁是否可以阻止多个线程进入临界区。 公平性：当锁可用时，是否每个线程有公平的机会去抢到锁，是否保障每个线程都有机会进入临界区。 性能：锁应用于高并发的场景，然而并发的初衷是为了提高效率，如果使用锁带来了很大的开销，那就类似于舍本逐末，买椟还珠了。 实现一个锁正如上图所示，当一个线程获得锁之后，他可以执行临界区中的代码。而没有获得锁的线程只能排队，直到获取到锁才可以执行临界区的代码。这样的设计保障了良好的互斥性。那么应该如何去实现呢。 我们可以用一个变量(flag)来标志锁是否被某个线程占用。 当第一个线程进入临界区后，它要把这个标志位设为1。 当一个线程想要进入临界区时，它首先要检查这个标志位是否1。如果是1那么证明锁被某个线程占用，所以它要等待锁。 当线程执行完临界区的代码时，它要将标志位设为0，释放锁的的所有权，以便其他线程使用。 12345678910111213141516171819202122232425262728293031323334typedef struct lock_t &#123;int flag;&#125; lockt_t;void init(lock_t *mutex) &#123; mutex-&gt;flag = 0; /* 初始状态为0 代表锁未被任何线程持有*/&#125;void lock(lock_t *mutex) &#123; /* 自旋等待 */ while (mutex-&gt;flag != 0); // spin-wait mutex-&gt;flag = 1;&#125;void unlock(lock_t *mutex) &#123; mutex-&gt;flag = 0;&#125;/* thread code */static lock_t mutex;static int counter = 10;&#123; init(&amp;mutex);&#125;void decrement() &#123; /* 尝试进入临界区 */ mutex-&gt;lock(); /* 进入临界区 */ counter++; /* 临界区代码执行完毕，释放锁 */ mutex-&gt;unlock(); /* 退出临界区 */&#125; 这样实现的锁有问题吗？，我们可以测试一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static lock_t mutex;static int counter = 0;const static int LOOP_CNT = 10000;void decrement() &#123; counter--;&#125;void increment() &#123; counter++;&#125;void *threadI(void *args) &#123; printf(&quot;thread %s\\n&quot;, (char*)args); int i; for (i = 0; i &lt; LOOP_CNT; ++i) &#123; lock(&amp;mutex); increment(); unlock(&amp;mutex); &#125; return NULL;&#125;void *threadD(void *args) &#123; printf(&quot;thread %s\\n&quot;, (char*)args); int i; for (i = 0; i &lt; LOOP_CNT; ++i) &#123; lock(&amp;mutex); decrement(); unlock(&amp;mutex); &#125; return NULL;&#125;int main() &#123; pthread_t th1,th2; init(&amp;mutex); pthread_create(&amp;th1, NULL, threadI, &quot;threadI&quot;); pthread_create(&amp;th2, NULL, threadD, &quot;threadD&quot;); pthread_join(th1, NULL); pthread_join(th2, NULL); printf(&quot;counter = %d\\n&quot;, counter); return 0;&#125; 结果出现了点小意外。 虽然这种状况出现的概率很小，但是出现即意味着我们在代码设计上有问题？那么问题出在了哪里呢。 问题便是，我们的锁也是一个共享的变量，在并发场景下同样会出现共享变量问题。也就是说我们对锁进行操作的代码在CPU看来同样不具备原子性。在我们实现锁的代码中，在对flag标识为进行赋值时，如果操作系统调度中断，那么很有可能出现两个线程同时将flag设置为1，同时拥有锁的现象。显然这连基本的互斥性都无法满足，那么这将是一个bad lock。那么应该怎么做，这就不得不依赖我们的硬件原语了。 test-and-settest-and-set是一种硬件原语。这种硬件原语能够保障指令的原子性。在SPARC上，这个指令叫做ldstub(load/store unsigned byte) 加载保存无符号字节。在x86平台上，是xchg(atomic exchange, 原子交换指令) 因为这是一个硬件方面的原语，我们只能以C代码的形式来定义一下这个硬件原语做了什么 12345int test_and_set(int *oldptr, int new) &#123; int old = *oldptr; *oldptr = new; return old;&#125; 我们用test-and-set这个硬件语言去重新实现一下我们的锁 12345678void lock(lock_t *mutex) &#123; /* 这段代码可以保证flag设置的原子性 */ while (test_and_set(&amp;mutex-&gt;flag, 1) == 1); // spin-lock&#125;void unlock(lock_t *mutex) &#123; mutex-&gt;flag = 0;&#125;","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://huobingnan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://huobingnan.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"操作系统","slug":"操作系统","permalink":"https://huobingnan.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"并发带来的共享数据问题","slug":"并发带来的共享数据问题","date":"2020-12-01T12:56:57.000Z","updated":"2020-12-01T12:59:10.756Z","comments":true,"path":"2020/12/01/并发带来的共享数据问题/","link":"","permalink":"https://huobingnan.github.io/2020/12/01/%E5%B9%B6%E5%8F%91%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/","excerpt":"","text":"并发带来的问题并发固然可以提高程序的运行效率。但是同样也带来了许多沉重的代价，例如： 共享数据问题。 并发同步问题。 BUG不易复现问题。 共享数据问题123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;static int counter = 0; /* 全局变量 *//* 对变量counter进行递增操作 */void *decrement(void *args) &#123; printf(&quot;In thread %s\\n&quot;, (char*)args); int i; for (i=0; i&lt;100000; ++i) counter--; return NULL;&#125;/* 对变量进行递减操作 */void *increment(void *args) &#123; printf(&quot;In thread %s\\n&quot;, (char*)args); int i; for (i=0; i&lt;100000; ++i) counter++; return NULL;&#125;int main() &#123; pthread_t p1,p2; int rc; rc = pthread_create(&amp;p1, NULL, decrement, &quot;DECREMENT&quot;); if (rc != 0) &#123; printf(&quot;thread [DECREMENT] create error!\\n&quot;); exit(-1); &#125; rc = pthread_create(&amp;p2, NULL, increment, &quot;INCREMENT&quot;); if (rc != 0) &#123; printf(&quot;thread [INCREMENT] create error!\\n&quot;); exit(-1); &#125; pthread_join(p1, NULL); pthread_join(p2, NULL); printf(&quot;counter = %d\\n&quot;, counter); return 0;&#125; 上述C语言代码逻辑很简单，一个线程对变量counter进行循环递增操作，另一个线程对变量进行循环递减操作，因为循环的次数是一样的，所以我们预期的结果是，最终counter的值不会改变。但是实际运行结果并不是这样。 上述代码执行结果的输出具有不确定性。 从运行结果来看，这并不符合我们的预期，而且大大超出了我们的预期，因为多次运行，结果却还不尽相同。 线程上下文和原子性之所以会产生这样的结果，根本原因在于线程在运行时处于不可控状态。也就是说，你无法确定某一时刻某个线程是否在运行。当我们创建好线程之后，线程的执行与调度将交由操作系统，我们无法管理我们的线程。 线程的调度，一般采用时间片轮转算法进行调度，即给一个线程分配一定的执行实行例如2ms，2ms之后操作系统会将这个线程当前运行的状态保存到TCB(Thread Control Block，主要用于调度中恢复线程的执行现场), 这个TCB也称为线程上下文。 正如我们所说，一个线程什么时候被执行，什么时候被挂起完全取决于操作系统，那么当线程用完CPU时间片时，线程函数中代码停止的位置也具有一定的随机性。但是这种随机性是导致出现共享数据问题的原因吗？ 答案是：不全是。导致共享数据问题的原因不仅仅在于线程的调度，还取决于指令的原子性。我们写的高级语言代码最终要编译为二进制数据保存于内存中，那么我们在高级语言中可以通过一行(一句)代码完成的事情，真正交给CPU去做的时候，可能需要好几个步骤。 例如上述代码中的counter++和counter--。这两句代码看起来好像是一步就可以完成，但是CPU真正去执行的时候并不是。我们可以通过gcc -S [source file]的方式，去查看编译后的汇编代码。 123movl counter(%rip), %eaxsubl $1, %eaxmovl %eax, counter(%rip) 通过汇编代码我们可以看到，counter--需要三个步骤才可以完成。同时也要注意，我们说代码停止运行的位置具有随机性，这个位置是对于最终的机器指令来说的。而不是针对于源代码来说。 我们看到CPU在执行的时候，首先它要讲counter从内存中转移至寄存器中。然后对寄存器中的值加上立即数1，然后再将加1之后的寄存器中的值转移至内存中。 我们可以将上述三个步骤分别用LOAD，CALC，STORE来代替。问题出现的关键点便在于，我们对数据进行CALC之后是否能及时的STORE至内存中，也就是，现在内存中的值，是否是一个最新的值(合理的值)。如果现在CALC之后，未来得及进行STORE操作就移交了CPU 的使用权，那么其他线程读取到的值，就不是一个合理的值。 那么什么是原子性，原子性就是我们期望事件不可再分。例如一条指令，我们期望他不会被分解为其他若干条指令。而是一次性，作为一个基本单元的去执行，并且在执行过程中不可能被中断。 上述代码的问题就在于，我们把counter++和counter--误以原子指令的形式去运行。 值得注意的是，有时候一条汇编指令并不一定代表一条原子指令。即汇编指令也不能保障原子性。原子性的保障还需依靠硬件系统的微指令来保障。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://huobingnan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://huobingnan.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"操作系统","slug":"操作系统","permalink":"https://huobingnan.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"进程与线程","slug":"进程与线程","date":"2020-12-01T12:47:27.000Z","updated":"2020-12-01T12:57:39.437Z","comments":true,"path":"2020/12/01/进程与线程/","link":"","permalink":"https://huobingnan.github.io/2020/12/01/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"并发无论是在操作系统层面还是在编程语言层面，都是一个极为重要的概念。线程(thread)是对并发的一种抽象，经典观念认为一个程序只有一个执行点(一个程序计数器，用来指向要执行的指令)。但是多线程(multi-thread)程序会有多个执行点(多个程序计数器)。换个角度来看，线程的概念类似于进程，有别于进程的地方就是多线程环境下，每个线程他们要共享地址空间，不同线程之间能够访问到共同的数据。 线程与进程十分相似，但又不同，进程是分时操作系统最早提出的一种任务调度模型。进程的出现使得操作系统拥有更好的交互性和更高的效率。在操作系统中，每个进程都有自己独立的地址空间，各个进程之间相互隔离，互补干扰。 而线程可以看做是更细粒度的一种进程。但是线程必须依赖于进程存在，没有独立于进程的线程。进程是操作系统分配资源的最小单位，线程是操作系统调度的最小单位。 现代分时操作系统中大部分操作系统都支持线程，线程成为了CPU，操作系统调度的最小单元。然而线程不仅仅局限于操作系统，线程这个抽象的概念也可以被程序设计语言去实现。所以按照线程的实现者的不同可以将线程分为两类： 用户线程：有程序设计语言实现(软件实现),不依赖于操作系统。 内核线程：操作系统实现，操作系统负责调度。 有关进程进程：一个具有独立功能的程序在数据集合上的一次动态执行过程。（进程的学术定义） 进程这个概念与程序，或者我们的代码有很大的联系。我们写出的代码最终要变成计算机可以识别的二进制语言存储于内存中，进程可以看做是代码的一次动态执行。有人说，程序=数据结构+算法。这种说法完全正确，但也可以退化来看：程序=数据+指令。所以进程就可以看做是数据和指令在计算机内的一次运行。 所以进程与程序的关系大致如下： 程序是产生进程的基础。 程序每次运行构成了不同的进程。 进程是程序功能的体现。 一个程序可以对应多个进程，通过调用关系，一个进程又可以包括多个程序。 同时进程与程序的区别大致如下： 进程是一个动态的概念。程序是一个静态的概念。程序是有序指令的集合，进程是程序的一次执行。 进程具有一定的时效性，它的运行周期可预期。 所以进程可以看作是程序的实例，程序可以看作是进程的模板。 进程的组成 code 代码 data 数据 PCB(Process Control Block) 进程控制块 进程的特点 动态性：进程可以被动态创建，也可以动态结束。 并发性：进程可以被独立调度，并占用处理机运行。 独立性：不同进程之间是相互隔离，互不影响的。 制约性：因访问共享资源(数据)或进程间同步而受到制约。 PCB的构成 进程标识信息 本进程标识 父进程标识 用户标识 处理器状态信息 用户可见寄存器 控制和状态寄存器：PC，PSW 栈指针 资源信息 进程的生命周期 有关线程线程是进程中的一条流程。从资源组合角度来看：进程把一组相关资源组合起来，构成了一个资源平台(环境)，包括地址空间(代码段，数据段),打开的文件等各类资源。从运行角度来看，代码在这个资源平台上执行的一个流程称为线程。 线程模型的优缺点 优点 一个进程可以存在多个线程(同时存在)。 各个线程之间可以并发地执行。 各个线程之间可以共享地址空间和文件资源。 缺点 一个线程的崩溃，有可能导致其所属进程的所有线程崩溃。 进程是资源分配的单位，线程是CPU调度的单位。进程拥有一个完整的资源平台，而线程只独享必不可少的资源，入寄存器和栈。同时线程具有与进程类似的五种状态，但是线程比较轻量能够减少并发时间和开销，线程的轻量级主要体现在如下方面： 线程的创建时间很短。 线程的终止时间很短。 同一进程内线程的切换时间很迅速。 同一进程内不同线程之间共享内存和文件等系统资源。 用户线程和内核线程 用户线程：用户线程是操作系统无法感知的线程，它不是由操作系统创建、调度、管理。不依赖于操作系统内核，它由一组用户级别的库函数完成，通过用户线程可以在不支持多线程模型的操作系统之上完成多线程编程。同时，用户线程的切换无须经过操作系统内核，所以它的切换会很快，同时用户还可以自己DIY线程的调度算法。但是用户态线程也有缺点，如果用户线程发起一个阻塞的系统的调用，那么它会阻塞整个进程内的所有用户线程。同时操作系统将时间片分给了进程，而没有直接分给线程，所以平均每个线程的执行时间会比较短，因此用户态线程执行起来会比较慢。 内核线程：操作系统内核中实现一种机制(线程机制)，由操作系统负责创建、调度、管理线程，使用者仅需发出线程创建相关的系统调用即可。但是内核线程的创建会经历用户态到内核态的转变，所以开销比用户线程大，但是内核线程由操作系统管理，因此当其中一个线程发生阻塞时，并不会影响到同进程内其他线程的工作，同时内核线程分得的CPU时间较多，执行效率较高。 C语言环境进程创建代码 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;/* 线程任务函数 */void *mythread(void *args) &#123; printf(&quot;%s\\n&quot;, (char*) args); return NULL;&#125;int main() &#123; pthread_attr_t p1Attr; /* 线程的属性 */ pthread_t p1; /* 线程 */ int rc; pthread_attr_init(&amp;p1Attr); /* 初始化线程属性 */ pthread_attr_setscope(&amp;p1Attr, PTHREAD_SCOPE_SYSTEM); /*与操作系统绑定*/ pthread_attr_setschedpolicy(&amp;p1Attr, SCHED_RR); /* 轮询的方式进行调度 */ puts(&quot;Hello world\\n&quot;); rc = pthread_create(&amp;p1, &amp;p1Attr, mythread, &quot;A&quot;); puts(&quot;Start a new thread\\n&quot;); rc = pthread_join(p1, NULL); return 0;&#125; pthread是POSIX Threads的简称。 POSIX，可移植操作系统接口（英文：Portable Operating System Interface）POSIX是IEEEE为要在各种UNIX操作系统上运行软件，而定义的一系列操作系统API接口，正式名称为IEEEE Std 1003，国际标准化组织名称 ISO/IEC 9945。 目前Linux基本上逐步实现了POSIX的兼容，但并未获得正式的POSIX认证。微软的Windows NT声称实现了部分POSIX标准。当前POSIX主要分为四部分：Base Definition、System Interfaces、Shell and Utillities、Rationale。 在Linux环境中，你可以使用&lt;pthread.h&gt;结合libpthread.so来创建线程，在Windows下可以使用MinGW结合pthread来创建线程，当然也可以使用&lt;windows.h&gt;中的windows API来创建线程，只不过&lt;pthread.h&gt;显得更加标准和易使用，但需要平台和工具的支持。 如你所见，线程的创建有点类似于函数的调用，然而，并不是首先执行函数然后返回给调用者，而是为调用的例程创建一个新的执行线程，它可以独立于调用者运行，至于函数什么时候被调用完全取决于操作系统(相应库函数的调度策略)。开玩笑的说：如果一个程序员遇到了一个问题，他想要用多线程去解决，那么他将面临两个问题。 那么使用多线程并发会带来哪些问题呢？","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://huobingnan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://huobingnan.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"操作系统","slug":"操作系统","permalink":"https://huobingnan.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"链表倒数第k个元素","slug":"链表倒数第k个元素","date":"2020-12-01T12:32:55.000Z","updated":"2020-12-01T12:40:24.726Z","comments":true,"path":"2020/12/01/链表倒数第k个元素/","link":"","permalink":"https://huobingnan.github.io/2020/12/01/%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E5%85%83%E7%B4%A0/","excerpt":"","text":"408真题，题目要求：给定一个无头节点的链表，其内存结构如下，设计算法找到链表中倒数第k个元素。若找到元素返回true并输出，找不到返回false。 思路分析：通过链表结构可知，链表中没有存储长度相关的信息。最直观的思路就是，首先对链表进行一次遍历，目的是获取链表的长度。然后通过链表的长度就可以确定倒数第k个元素所在的位置，因此再次进行链表遍历即可获得倒数第k个元素。 上述方法，我称之为暴力求解法，还有一个比较好的思路就是使用两个指针。这两个指针都指向链表的某个元素，但是有一些要求，两个指针间隔要相差k个元素。这样我们同时移动两个指针，当靠前的指针遍历到链表尾部时 （null）那么后面指针指向的元素就是倒数第k个元素咯。 C++ AC代码1234567891011121314151617bool get_count_backword_k(list_t *_list, int _k)&#123; lnode_t *cur = _list, *aux = _list; while (aux != nullptr) &#123; aux = aux-&gt;next; if (_k-- &lt;= 0) &#123; cur = cur-&gt;next; &#125; &#125; if (cur == _list) &#123; return false; &#125; else &#123; std::cout &lt;&lt; cur-&gt;data &lt;&lt; &quot;\\n&quot;; return true; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://huobingnan.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://huobingnan.github.io/tags/algorithm/"}]},{"title":"JavaScript原型链","slug":"JavaScript原型链","date":"2020-11-30T11:40:24.000Z","updated":"2020-12-01T05:19:51.171Z","comments":true,"path":"2020/11/30/JavaScript原型链/","link":"","permalink":"https://huobingnan.github.io/2020/11/30/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"前言JavaScript一款基于原型的编程语言，原型实际上是一种设计模式。JavaScript语言之所以基于原型去设计，我猜测与最初的语言应用场景有关。最初，JavaScript是一款运行于浏览器中的语言（当然现在JavaScript的运行环境越来越丰富，完全可以脱离浏览器运行），既然是基于浏览器，那么编程语言在设计上就要考虑内存的占用问题，而原型设计模式在内存占用与代码复用上都无比适合于浏览器环境。 若要我用一句话来说JavaScript的原型到底是什么，我想它应该是一个可复用的单例。这里有两个关键词，可复用与单例，单例也是一种设计模式，它是对象创建模式的一种，单例最大的好处就在于能够节省内存，避免不必要的对象多次创建。但是单例模式没有很好的可复用性，所以JavaScript采用原型链来解决可复用性问题。 由原型链引发的一些思索从字面意思上来看，原型链是一种链式结构。JavaScript中每个对象都有一个原型，这是必然。在不同的JavaScript Runtime Environment中，对象原型会有所不同。本文以Node.js运行环境为例进行介绍。 初探原型链 JavaScript中每个对象都有一个”属性“__proto__，实际上它并不是属性，而是一个属性访问器(Accessor)， 通过它你可以获取到一个对象的原型。对象的原型也是一个对象，所以对象的原型也有__proto__，这样就构成了一个链式的结构，没错这就是对象的原型链。 12const s = &quot;hello world&quot;;console.log(s.__proto__); prototype 在JavaScript中还有另一个与原型链十分重要的概念那就是prototype，prototype是一个属性，但是它并不是一个所有对象都拥有的属性，这个属性仅存在于function对象中。在我看来，能够明确prototype与__proto__之间的区别，你会对JavaScript语言设计的理解上升一个层次。 JavaScript中常见的几种数据类型，分别是： 数组类型，字符串类型，数字类型，函数类型，集合类型，映射类型。 123456Array; // 数组构造函数String; // 字符串构造函数Number; // 数字构造函数Function; // 函数构造函数Map; // 映射构造函数Set; // 集合构造函数 其实在JavaScript中比较容易混淆的一个概念是构造函数和类型，其实这是两个不同的概念。 1console.log(&quot;&quot;.__proto__ === String); // false 在JavaScript中函数也是对象，String，Array他们并不是类型，而是对象，一种特殊的对象。这种对象可以派生其他的对象，当它们被当作构造函数使用时，但是StringObject和String并没有父与子的关系，它们两个的关系是平等的，是好兄弟的关系。 我在上文中也提到过，任何对象都有一个原型，那么我通过构造函数新创建出来的对象它以哪个对象为原型呢？首先我们可以排除它肯定不是以构造函数对象为原型的，上面的例子中我们也证明了。 答案是：通过构造函数对象new出来的对象是以构造函数中的一个属性prototype所指向的对象为原型的。 1console.log(&quot;&quot;.__proto__ === String.prototype); // true 原型链的作用 文章最开始说，JavaScript的原型可以看作是可复用的单例。那么原型链就是为了解决复用性问题。 首先JavaScript是面向对象的程序设计语言。既然面向对象那么就会有属性和方法的概念。在其他面向对象的程序设计语言中，对象其实就是数据（属性）的集合。至于方法在内存中其实只存在一份。JavaScript的原型链设计也有这方面的考量，但是更多的像是通过原型链的方法借用，对象仍然是数据的集合。 1234let obj = &#123; name: &quot;hello&quot;&#125;;console.log(obj.hasOwnProperty(&quot;name&quot;)); // true 对于对象obj它并没有hasOwnProperty这个方法，但是我们仍然可以调用，这是为什么呢？ 答案其实是原型链在起作用，对象自己没有的方法和属性可以在原型链上向上找寻。 我们来看一下obj的原型链。 没错方法就存在于obj的原型对象中，我们可以写个代码测试一下。 1234Object.prototype.hasOwnProperty = function (name) &#123; return name;&#125;;console.log(obj.hasOwnProperty(&quot;name&quot;)); // name 原型链是一个单向链，原型链上的对象可以看作是父与子的关系。 继承继承是原型的继承，JavaScript是面向对象的程序设计语言，所以自然会有对象之间的继承，组合等关系。上文讲到JavaScript原型链上的对象有着父与子的关系。所以JavaScript中的继承也是通过原型链来实现的。 123456789101112131415function Shape() &#123;&#125;Shape.prototype.draw = function () &#123; console.log(`drawing $&#123;this.name&#125;`);&#125;function Rectangle() &#123; this.name = &quot;矩形&quot;;&#125;// 继承是原型的继承Rectangle.prototype.__proto__ = Shape.prototype;let r = new Rectangle();r.draw();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://huobingnan.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://huobingnan.github.io/tags/JavaScript/"}]},{"title":"Mybatis源码阅读环境搭建教程","slug":"Mybatis源码阅读环境搭建教程","date":"2020-11-27T14:20:26.000Z","updated":"2020-11-27T14:35:57.462Z","comments":true,"path":"2020/11/27/Mybatis源码阅读环境搭建教程/","link":"","permalink":"https://huobingnan.github.io/2020/11/27/Mybatis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/","excerpt":"","text":"Mybatis是一款优秀的Java ORM框架，想要深入学习它，自然要从源码开始。但是源码阅读的学习通常伴随着复杂头痛的配置，本篇文章让您用最简单的步骤配置好Mybatis的源码阅读环境。 源码下载 Mybatis的官方仓库位于Github上，你可以直接从官方下载最新版本的源码进行阅读，但是这里推荐给你一种更好的选择，那就是优秀的程序员tuguangquan上传的中文注释版本的Mybatis源码，并且在他的仓库中详细的阐述的Mybatis源码的配置教程，这里借鉴了前辈的做法，并且做了一些小改动，使源码阅读环境配置更加便利。 国内的网友推荐使用我配置完毕的gitee仓库下载源码以及依赖(网速比较快，在没有TZ的情况下)。 在源码阅读之前，请首先配置好你的源码目录，在你本地电脑的任意位置创建一个名为mybatis的文件夹，并且进入到这个文件夹。紧接着我们开始下载源码。 首先下载mybatis-parent的源码：gitee地址 =&gt; https://gitee.com/callback_lab/mybatis-parent.git 然后下载mybatis的源码：gitee地址 =&gt; https://gitee.com/callback_lab/mybatis-src.git 源码下载完毕之后，我们的目录结构应该是这样子的： 123- mybatis - mybatis-parent - mybatis-src 导入到IDEA 导入到IDEA之后，更新Maven工程，处理好依赖之后，点击LifeCycle进行编译。 至此，若无报错信息，我们的Mybatis源码的阅读环境就算是搭建完毕了。 注意事项 请务必保障目录结构如1中所述，不然会导致出错。 处理好依赖信息之后再进行编译操作。","categories":[{"name":"Java","slug":"Java","permalink":"https://huobingnan.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://huobingnan.github.io/tags/Java/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://huobingnan.github.io/tags/Tutorial/"}]},{"title":"二分查找树(Java实现)","slug":"二分查找树-Java实现","date":"2020-11-26T13:45:38.000Z","updated":"2020-11-26T13:50:16.316Z","comments":true,"path":"2020/11/26/二分查找树-Java实现/","link":"","permalink":"https://huobingnan.github.io/2020/11/26/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A0%91-Java%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"二叉搜索树(Binary Search Tree，BST)，是一棵空树或者一棵具备以下特征的二叉树： 若左子树非空，则左子树所有节点的值都小于根节点的值。 若右子树非空，则右子树所有节点的值都大于根节点的值。 左、右子树又分别为一棵二叉排序树。 二叉搜索树是一种有序的半线性数据结构，如果使用链式的物理存储方式，那么二叉搜索树在查找和插入操作（维持数据有序的前提下）有着不错的表现，这得益于二叉树具备有良好的二分特性，所以在设计算法时可以很好的利用二分的思想。 BST的Java语言实现BST的主要操作有插入、删除、搜索、序列化。 插入：将一个值插入到BST中。 删除：若BST存在有待删除的值，则将其从BST中移除。 搜索：查看BST中是否包含有某个值。 序列化：将BST序列化为一维有序序列。 BST 定义123456789101112131415161718192021222324252627282930313233/** * Binary Search Tree 非递归实现版本 * @author callback * @param &lt;T&gt; 数据域模板参数 * @version 1.0.0 * @copyright (c) 2020 */public class BST&lt;T extends Comparable&lt;T&gt;&gt;&#123; /* Binary Search Tree Node */ private static class TreeNode&lt;T extends Comparable&lt;T&gt;&gt; &#123; private TreeNode&lt;T&gt; left; /* 左节点 */ private TreeNode&lt;T&gt; right; /* 右节点 */ private TreeNode&lt;T&gt; parent; /* 双亲节点 */ private T data; /* 数据域 */ TreeNode() &#123;&#125; TreeNode(T data) &#123; this.data = data; &#125; TreeNode(TreeNode&lt;T&gt; parent, T data) &#123; this.parent = parent; this.data = data; &#125; &#125; private TreeNode&lt;T&gt; root = null; /* 根节点 */ private int size = 0; /* BST的规模 */&#125; 插入操作二叉树是一种动态树表，其特点是树的结构通常不是一次性生成的，而是在查找过程中，当树中不存在关键字值等于给定值的节点时在进行插入。 1234567891011121314151617181920/* 插入操作 */public void insert(T data)&#123; TreeNode&lt;T&gt; p = root; TreeNode&lt;T&gt; parent = null; /* 记录双亲节点 */ while (p != null) &#123; parent = p; if (data.compareTo(p.data) &gt; 0) p = p.right; else if (data.compareTo(p.data) &lt; 0) p = p.left; &#125; if (parent == null) &#123; root = new TreeNode&lt;&gt;(null, data); size++; return; &#125; if (data.compareTo(parent.data) &lt; 0) parent.left = new TreeNode&lt;&gt;(parent, data); else if (data.compareTo(parent.data) &gt; 0) parent.right = new TreeNode&lt;&gt;(parent, data); size++;&#125; 查找操作123456789101112/* 查看BST中是否包含 @param data */public boolean contains(T data)&#123; TreeNode&lt;T&gt; p = root; for (;;) &#123; if (p == null) return false; if (data.compareTo(p.data) &gt; 0) p = p.right; else if (data.compareTo(p.data) &lt; 0) p = p.left; else return true; &#125;&#125; 删除操作在BST中删除一个节点时，不能把以该节点为根的子树上的节点都删除。正确的操作是，将待删除的节点从BST中摘下，然后将以该节点为根的节点重新链起来。为确保BST的性质不会丢失，删除操作要分三种情况处理： 删除的节点是一个叶子节点，这种情况直接删除即可，不会破坏BST的性质。 删除的节点只有一棵左子树或右子树，删除时让删除节点的子树成为其父节点的子树即可。 删除的节点有左右两棵子树，这种情况较为复杂，一般让该节点的直接后继节点(中序遍历中的下一个节点)代替当前节点，然后，将直接后继节点的父节点的左子树设置为直接后继节点的右子树即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* 删除操作 */public boolean delete(T data)&#123; TreeNode&lt;T&gt; p = root; for (;;) &#123; if (p == null) return false; if (data.compareTo(p.data) == 0) break; else if (data.compareTo(p.data) &lt; 0) p = p.left; else p = p.right; &#125; if (p.left == null &amp;&amp; p.right == null) &#123; if (p == root) &#123; root = null; &#125; else &#123; if (data.compareTo(p.parent.data) &lt; 0) &#123; p.parent.left = null; &#125; else if (data.compareTo(p.parent.data) &gt; 0) &#123; p.parent.right = null; &#125; &#125; &#125; else if (p.left == null) &#123; if (p == root) &#123; root = root.right; &#125; else &#123; if (data.compareTo(p.parent.data) &lt; 0) &#123; p.parent.left = p.right; &#125; else if (data.compareTo(p.parent.data) &gt; 0) &#123; p.parent.right = p.right; &#125; &#125; &#125; else if (p.right == null) &#123; if (p == root) &#123; root = root.left; &#125; else &#123; if (data.compareTo(p.parent.data) &lt; 0) &#123; p.parent.left = p.left; &#125; else if (data.compareTo(p.parent.data) &gt; 0) &#123; p.parent.right = p.left; &#125; &#125; &#125; else &#123; /* 待删除节点既有左节点又有右节点 */ TreeNode&lt;T&gt; next = getNextTreeNode(p); /* 获取该节点的直接后继节点 */ p.data = next.data; /* 用直接后继节点的数据更新当前节点 */ next.parent.left = next.right; /* 删除直接后继节点，直接后继节点的一定为一个极左节点。 */ &#125; size--; return true;&#125;/* 获取一个节点的直接后继节点 */private TreeNode&lt;T&gt; getNextTreeNode(TreeNode&lt;T&gt; node)&#123; if (node == null) return node; if (node.right != null) &#123; node = node.right; while (node.left != null) node = node.left; return node; &#125; else &#123; TreeNode&lt;T&gt; parent = node.parent; while (parent != null &amp;&amp; parent.left != node) &#123; node = parent; parent = node.parent; &#125; return parent; &#125;&#125; 查找最值BST的最值很好查找，只要一直沿着右子树去遍历，那么得到的就是最大值。一直沿着左子树去遍历，那么得到的就是最小值。 12345678910111213141516171819/* 查找BST中的最大值 */public T max()&#123; TreeNode&lt;T&gt; p = root; while (p != null &amp;&amp; p.right != null) &#123; p = p.right; &#125; return p != null ? p.data : null;&#125;/* 查找BST中的最小值 */public T min()&#123; TreeNode&lt;T&gt; p = root; while (p != null &amp;&amp; p.left != null) &#123; p = p.left; &#125; return p != null ? p.data : null;&#125; 总结BST这种数据结构能够维持数据的有序性，并且相对于普通的一维线性结构在性能上有着一定的优势，但是这种优势很不稳定。一般情况下，我们期望BST是横向增长速度高于纵向生长速度，即我们期望BST的是朝着枝繁叶茂的趋势去增长，但是一旦BST的纵向生长速度超过了横向生长速度，那么BST就会退化为一维的链表结构。这样在插入和查找上的性能就会有所损耗。所以为了让树的结构符合我们的预期，我们需要对树的”生长“以及”修剪“进行一定的约束。这也就有了后来的AVL树和红黑树。","categories":[{"name":"Java","slug":"Java","permalink":"https://huobingnan.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://huobingnan.github.io/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://huobingnan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Windows下安装MySQL教程","slug":"Windows下安装MySQL教程","date":"2020-11-26T10:12:40.000Z","updated":"2020-11-26T10:18:23.145Z","comments":true,"path":"2020/11/26/Windows下安装MySQL教程/","link":"","permalink":"https://huobingnan.github.io/2020/11/26/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL%E6%95%99%E7%A8%8B/","excerpt":"","text":"下载MySQL安装包 从MySQL官网下载相应版本的安装包mysql官网地址。 安装包分为.msi安装包与.zip压缩安装包。本文以.zip压缩包的形式介绍Windows下安装配置MySQL的过程。 撰写配置文件 进入解压缩之后的MySQL安装包，一般情况下，其目录结构如下： 123456- mysql-xxxx-winx64 - bin - docs - lib - include - share 在此目录下创建一个名为my.ini的配置文件，并编辑其内容为: 12345678910111213141516[client]port=3306default-character-set=utf8[mysqld] # 设置为自己MYSQL的安装目录 basedir=F:/mysql-5.7.25-winx64# 设置为MYSQL的数据目录 datadir=F:/mysql-5.7.25-winx64/dataport=3306character_set_server=utf8sql_mode=NO_ENGINE_SUBSTITUTION,NO_AUTO_CREATE_USER#开启查询缓存explicit_defaults_for_timestamp=true#设置时区default-time_zone=+8:00secure_file_priv= 配置环境变量与注册服务 环境变量注册： 右键我的电脑 –&gt; 点击属性 –&gt; 高级系统设置 –&gt; 环境变量 –&gt; 新建环境变量MYSQL_HOME，变量值为MySQL的安装目录。–&gt; 编辑PATH变量，添加项%MYSQL_HOME%\\bin –&gt; 保存。 配置完成环境变量之后，可以进行MySQL服务的初始化与注册工作。 MySQL初始化： win + R，输入CMD进入命令提示符界面，进入MySQL安装目录的bin目录下，一定要在此目录下执行下面的命令，不然会出现BUG 。 输入mysqld --initialize，初始化MySQL数据库。 若这一步骤出错，请将my.ini文件更改为ASNI编码格式保存。 初始化完毕后，进入data目录，打开文件callback.err查找初始化登录密码: 12020-11-15T05:01:16.628365Z 1 [Note] A temporary password is generated for root@localhost: ?az:cRvVc7QY &lt;--- 这个是初始化登录密码,登录之后可以修改。 将MySQL注册为系统服务： 打开命令提示符程序并输入: 1mysqld --install MySQL MySQL服务的开启与关闭 开启服务：net start MySQL。 关闭服务：net stop MySQL。 修改初始化密码 使用mysql连接MySQL服务器。然后修改默认密码。 1alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;xxxxx&#x27;;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://huobingnan.github.io/categories/MySQL/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://huobingnan.github.io/tags/Tutorial/"},{"name":"MySQL","slug":"MySQL","permalink":"https://huobingnan.github.io/tags/MySQL/"}]}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://huobingnan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"algorithm","slug":"algorithm","permalink":"https://huobingnan.github.io/categories/algorithm/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://huobingnan.github.io/categories/JavaScript/"},{"name":"Java","slug":"Java","permalink":"https://huobingnan.github.io/categories/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"https://huobingnan.github.io/categories/MySQL/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://huobingnan.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"操作系统","slug":"操作系统","permalink":"https://huobingnan.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"algorithm","slug":"algorithm","permalink":"https://huobingnan.github.io/tags/algorithm/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://huobingnan.github.io/tags/JavaScript/"},{"name":"Java","slug":"Java","permalink":"https://huobingnan.github.io/tags/Java/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://huobingnan.github.io/tags/Tutorial/"},{"name":"数据结构","slug":"数据结构","permalink":"https://huobingnan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"MySQL","slug":"MySQL","permalink":"https://huobingnan.github.io/tags/MySQL/"}]}